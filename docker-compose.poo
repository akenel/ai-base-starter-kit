# Convert Windows path to Unix-style for Docker
$env:PWD = (Get-Location).Path -replace '\\', '/'

# Debug: Show converted path
Write-Host "Converted PWD: $env:PWD"

# ✅ Load environment variables correctly from .env
if (Test-Path .env) {
    Get-Content .env | ForEach-Object {
        if ($_ -match '^\s*([^#=]+?)\s*=\s*(.*)\s*$') {
            Set-Item -Path "Env:$($matches[1])" -Value $matches[2]
        }
    }
} else {
    Write-Host "⚠️ Warning: .env file not found!"
}

# Debug: Show loaded variables
Write-Host "Using Database: $env:DB_POSTGRESDB_DATABASE"
Write-Host "Using User: $env:DB_POSTGRESDB_USER"

# ✅ Generate init.sql file dynamically
$initSql = @"
DO
\$do\$
BEGIN
   IF NOT EXISTS (SELECT FROM pg_database WHERE datname = '$env:DB_POSTGRESDB_DATABASE') THEN
      CREATE DATABASE $env:DB_POSTGRESDB_DATABASE;
      CREATE USER $env:DB_POSTGRESDB_USER WITH PASSWORD '$env:DB_POSTGRESDB_PASSWORD';
      GRANT ALL PRIVILEGES ON DATABASE $env:DB_POSTGRESDB_DATABASE TO $env:DB_POSTGRESDB_USER;
   END IF;
END
\$do\$;
"@

Set-Content -Path postgres/init.sql -Value $initSql
Write-Host "✅ Generated init.sql with dynamic values."

# ✅ Ensure permissions on init.sql (avoids Windows mount issues)
Set-ExecutionPolicy Bypass -Scope Process -Force
icacls postgres/init.sql /grant Everyone:F

# ✅ Remove existing containers and volumes
docker-compose down --remove-orphans
docker system prune --volumes -f

# ✅ Start containers
docker-compose up -d --build
